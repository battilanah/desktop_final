
include::../../header.adoc[]

image::banner.png[width=100%]

Gradle est un outils qui permet d'écrire des scripts de build en groovy (et en kotlin).

Il permet d'exécuter une succession de tâches : un build.

La définition du build est contenu dans le fichier *build.gradle* à la racine du projet.

Voici un exemple simple de build.gradle pour un projet java :

.build.gradle
----
apply plugin: 'java'
----

En java, le produit du build est souvent un *jar* (java archive) ou un *war* (web archive - ie, une application web).

.Alternatives
****
Les principales alternatives à gradle dans le monde java sont

* *ant* : le premier outils de build en java configuré en xml. Assez daté.
* *maven* : aussi en xml. Lourd mais très structuré.
****

*Les dépendances*

Pour développer, on a rapidement besoin de librairies. Celles ci sont appelées *dépendances* (.jar en java).

Gradle va les chercher dans des *repositories* distants afin de pouvoir compiler notre code.


.build.gradle
----
dependencies {
    implementation 'org.slf4j:slf4j-api:1.7.12' <1>
}
----
<1> Ici notre projet utilise la lib slf4j-api en version 1.7.12

== Installation

Sous mac, le plus simple est de passer par http://brew.sh/[homebrew, window="_blank"].

.package manager
****
Homebrew est un package manager, comme apt-get ou rpm.

Il permet de gérer les logiciels installés sur sa machine.
****

[source.terminal]
----
test-project$ brew install gradle
----

Sans homebrew, voici la https://docs.gradle.org/current/userguide/installation.html[documentation, window="_blank"]

⇰ On peut vérifier que l'installation a réussie

[source.terminal]
----
test-project$ gradle -v

------------------------------------------------------------
Gradle 4.9
------------------------------------------------------------

Build time:   2018-07-16 08:14:03 UTC
Revision:     efcf8c1cf533b03c70f394f270f46a174c738efc

Kotlin DSL:   0.18.4
Kotlin:       1.2.41
Groovy:       2.4.12
Ant:          Apache Ant(TM) version 1.9.11 compiled on March 23 2018
JVM:          1.8.0_25 (Oracle Corporation 25.25-b02)
OS:           Mac OS X 10.10.5 x86_64
----

== gradle init

⇰ Nous allons rajouter les fichiers lié à la définition du build gradle dans notre projet.

[source.terminal]
----
test-project$ gradle init

BUILD SUCCESSFUL in 1s
2 actionable tasks: 2 executed
----

⇰ On peut voir les fichiers générés.

[source.terminal]
----
test-project$ ls -la
total 40
drwxr-xr-x   8 dbourdette  staff   272  8 aoû 15:20 .
drwxr-xr-x  18 dbourdette  staff   612  8 aoû 15:19 ..
drwxr-xr-x   3 dbourdette  staff   102  8 aoû 15:20 .gradle          <1>
-rw-r--r--   1 dbourdette  staff  1170  8 aoû 15:20 build.gradle     <2>
drwxr-xr-x   3 dbourdette  staff   102  8 aoû 15:20 gradle           <3>
-rwxr-xr-x   1 dbourdette  staff  5299  8 aoû 15:20 gradlew          <4>
-rw-r--r--   1 dbourdette  staff  2260  8 aoû 15:20 gradlew.bat      <5>
-rw-r--r--   1 dbourdette  staff   585  8 aoû 15:20 settings.gradle  <6>
----
<1> répertoire de cache
<2> le fichier de build
<3> répertoire qui contient le wrapper
<4> script wrapper pour linux
<5> script wrapper pour windows
<6> config multi projet

Ou via la commande `tree` (que l'on peut installer avec homebrew `brew install tree`)

[source.terminal]
----
test-project$ tree
.
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── settings.gradle
----

Les fichiers *gradlew*, *gradlew.bat* et le répertoire *gradle* constitue le *wrapper*.
Il permettent de lancer le build sans avoir à installer préalablement gradle.
C'est pratique pour de l'intégration continue ou bien pour tester rapidement sur une machine qui n'a pas gradle.

.Gradle wrapper
****
The Gradle Wrapper (henceforth referred to as the “wrapper”) is the preferred way of starting a Gradle build. The wrapper is a batch script on Windows, and a shell script for other operating systems. When you start a Gradle build via the wrapper, Gradle will be automatically downloaded and used to run the build.

source https://docs.gradle.org/current/userguide/gradle_wrapper.html
****

Le fichier *https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html[settings.gradle, window="_blank"]* est utile dans le cas d'un projet qui a des sous modules.

On peut ajouter un *gradle.properties* qui permet de https://docs.gradle.org/current/userguide/build_environment.html[configurer l'environnement de build, window="_blank"]

Le fichier *https://docs.gradle.org/current/userguide/tutorial_using_tasks.html[build.gradle, window="_blank"]* est celui qui contient la logique du build.

En l'état, il est preque vide :

[source,java]
----
/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn how to create Gradle builds at https://guides.gradle.org/creating-new-gradle-builds/
 */
----

== gradle build

⇰ Pour commencer, on remplace le contenu de notre build.gradle

[source,groovy]
----
apply plugin: 'java' <1>

repositories {
    jcenter() <2>
}

dependencies { <3>
}
----
<1> on ajoute le plugin java
<2> on utilise le repositroy https://bintray.com/bintray/jcenter[jcenter, window="_blank"]
<3> nos dépendances iront ici

.DSL
****
Le language du fichier build.gradle est du *groovy*, un language alternatif à java pour la jvm.

La souplesse de groovy permet de définir une synthaxe spécifique pour le build.

Un *Domain Specific Language* (DSL) : c'est une synthaxe particulièrement adaptée à un problème donné.
****

⇰ Avec la commande `gradle build`, on obtient

[source.terminal]
----
test-project$ gradle build

BUILD SUCCESSFUL in 0s
1 actionable task: 1 up-to-date
----

Cela génère le fichier jar `test-project.jar` dans build/libs

[source.terminal]
----
.
├── build
│   ├── libs
│   │   └── test-project.jar
│   └── tmp
│       └── jar
│           └── MANIFEST.MF
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── settings.gradle
----

== Tuning

=== Version

⇰ Si on souhaite que notre jar soit versionné, on peut rajouter le gradle.properties à la racine.

[source,properties]
.gradle.properties
----
version=0.1.0
----

⇰ Un `gradle clean build` donne alors

[source.terminal]
----
.
├── build
│   ├── libs
│   │   └── test-project-0.1.0.jar
│   └── tmp
│       └── jar
│           └── MANIFEST.MF
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
└── settings.gradle
----

.semver
****
Le produit est très souvent labelisé afin d'identifier une version.

Par exemple : mon-projet-*1.1.3*.zip.

La forme de numérotation la plus répandue est http://semver.org/[semver, window="_blank"]) pour Semantic Versioning.
****

=== Version de java

La version de java permet de définir le niveau de language supporté.

⇰ On change le sourceCompatibility dans le build.gradle

[source,groovy]
.build.gradle
----
apply plugin: 'java'

repositories {
    jcenter()
}

sourceCompatibility=1.8 <1>

dependencies {
}
----
<1> notre code sera compilé en java 8

IMPORTANT: Il faut maintenant un jdk 8 par défaut sur sa machine pour compiler notre projet.

== Tâches

`build` n'est qu'une tâche disponible parmis d'autres.

⇰ Il est possible de définir simplement ses propres tâches

[source,groovy]
.build.gradle
----
apply plugin: 'java'

repositories {
    jcenter()
}

sourceCompatibility=1.8

task hello {
    doLast {
        println 'Hello world!'
    }
}

dependencies {
}
----

[source.terminal]
----
test-project$ gradle hello

> Task :hello
Hello world!

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
----

Chaque plugin, comme le https://docs.gradle.org/current/userguide/java_plugin.html[plugin java, window="_blank"] apporte son lot de tâches et de conventions.

⇰ La liste des tâches est disponible via `gradle tasks`

== Dépendances

Une dépendance est une librairie nécessaire pour son projet.

⇰ Par exemple, afin d'utiliser junit pour les tests :

[source,groovy]
.build.gradle
----
apply plugin: 'java'

repositories {
    jcenter()
}

sourceCompatibility=1.8

dependencies {
    testImplementation 'junit:junit:4.12' <1>
}
----
<1> on prend la version *4.12* de *junit* qui est dans le groupe *junit* (format `groupId:articfactId:version`).

junit sera donc disponible pour les tests (configuration **testImplementation** des dépendances).

La liste des configurations pour le plugin java est disponible sur la https://docs.gradle.org/current/userguide/java_plugin.html#tab:configurations[page du plugin, window="_blank"]

Une configuration peut être vue simplement comme un groupe de dépendances avec un nom.

.What is a configuration?
****
Every dependency declared for a Gradle project applies to a specific scope. For example some dependencies should be used for compiling source code whereas others only need to be available at runtime. Gradle represents the scope of a dependency with the help of a Configuration. Every configuration can be identified by a unique name.

Many Gradle plugins add pre-defined configurations to your project. The Java plugin, for example, adds configurations to represent the various classpaths it needs for source code compilation, executing tests and the like. See the Java plugin chapter for an example. The sections above demonstrate how to declare dependencies for different use cases.

source https://docs.gradle.org/current/userguide/managing_dependency_configurations.html
****

== Les repositories distants

Gradle va chercher les dépendances dans des https://docs.gradle.org/current/userguide/dependency_management_for_java_projects.html#sec:repositories_java_tutorial[repositories] (des bibliothèques contenant des libs java).

Ici, nous avons utilisé https://bintray.com/bintray/jcenter[jcenter, window="_blank"]. Il existe aussi un autre repository public majeur : http://search.maven.org/[mavenCentral]

Il est possible de configurer un repository au sein d'une entreprise et de pointer dessus :

[source,groovy]
.build.gradle
----
repositories {
    maven {
        url "http://repo.mycompany.com/maven2"
    }
}
----

Ce repository servira notamment à stocker nos propres libraires que nous produisons.

Il est alors possible d'utiliser celles ci dans d'autres projets.

== Plugins

Voici quelques https://docs.gradle.org/current/userguide/standard_plugins.html[plugins standards, window="_blank"] :

* les languages : java, groovy, scala, c et cpp
* applications : application, ear, war et maven
* qualité : checkstyle, codenarc, findbugs, jdepend, pmd et sonar

Et bien sûr un https://plugins.gradle.org/[moteur de recherche de plugins] sur le site de gradle.

include::../../footer.adoc[]